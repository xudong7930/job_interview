#mysql
```
    CRUD
    JOIN、LEFT JOIN 、RIGHT JOIN、INNER JOIN
    UNION
    GROUP BY + COUNT + WHERE 组合案例
    常用 mysql 函数，如：now()、md5()、concat()、uuid()等
    1:1、1:n、n:n 各自适用场景
    了解触发器是什么，说个使用场景
    数据库优化手段
    索引、联合索引（命中条件）
    分库分表（水平分表、垂直分表）
    分区
    会使用 explain 分析 SQL 性能问题，了解各参数含义
    重点理解 type、rows、key
    Slow Log（有什么用，什么时候需要）
```

#mysql
```
    mysql体系结构
    字段类型
    char和varchar数据类型区别
    常见索引
    聚族索引和非聚族索引的区别
    事务机制
    BTree与BTree-/BTree+索引原理
    参考资料
```


# https://github.com/best90/php-interview/blob/master/mysql/Base.md

# MyISAM 和 InnoDB 的区别
```
MyISAM 查询效率更高，但是不支持事物
InnoDB 插入、更新较高，支持事物处理
MyISAM 支持表锁， InnoDb 支持行锁
MyISAM 是默认引擎，InnoDB 需要指定
InnoDB 不支持 FULLTEXT 类型的索引
```

# mysql lock
```
乐观锁: 乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好
悲观锁：悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作
共享锁：读锁（S锁），就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改
排他锁：写锁（X锁），排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。
```


#什么是 mysql 死锁？如何有效降低死锁？
```
死锁：死锁一般是事务相互等待对方资源，最后形成环路，而无法继续运行。

产生死锁的原因：
    系统资源不足；
    进程运行推进的顺序不合适；
    资源分配不当等；

如何有效降低死锁：
    按同一顺序访问资源；
    避免事务中的用户交互；
    保持事务简短并在一个批处理中；
    使用低隔离级别；
    使用绑定连接；
```

#避免死锁
```
如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会
在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率
降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大

```


#事务
```
如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：
    原子性（Atomicity）
    一致性（Consistency）
    隔离性（Isolation）
    持久性（Durability）

以上是事务的四大特性(简称ACID)，其中事务的隔离性， 当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作， 以保证各个线程获取数据的准确性，如果不考虑事务的隔离性，会发生的几种问题：

    脏读：一个事务内修改了数据，另一个事务读取并使用了这个数据；
    幻读：一个事务内修改了涉及全表的数据，另一个事务往这个表里面插入了新的数据，第一个事务出现幻读；
    不可重复读：一个事务内连续读了两次数据，中间另一个事务修改了这个数据，导致第一个事务前后两次读的数据不一致；
    更新丢失：一个事务内变更了数据，另一个事务修改了这个数据，最后前一个事务commit导致另一个事务的变更丢失；
```

#数据库的优化方式？

* https://cloud.tencent.com/developer/article/1004367

```
1.合理的设计表结构、表索引; 务必有自增主键。通过自增主键来查数据是最快的; 常用的查询字段建立联合索引，写SQL一定要尊从最左原则，用到这个索引。
2.不在数据库中做运算;不要把逻辑运算放到sql里。言外之意是，不要写太复杂的SQL，你能写复杂的SQL 你肯定也能通过PHP实现。
3.控制单表数据量
4.数据量过大进行读写分离，使用INNODB存储引擎
5.不再数据表中存储图片
```

#SQL语句的优化?
```
1.避免使用 Like 模糊查询
2.只列出需要查询的字段，而不是所有
3.不在 mysql 中进行运算，减轻 mysql 的压力
4.经常查询的字段，创建合适的索引，提高查询效率
```

#mysql优化怎么做的？
```
从整个项目环境来谈优化,具体可以分为3个方面:
硬件层面:
    采用高配sass硬盘、上磁盘阵列
架构层面:
    分库、分区、分表、主从(主主)、多服务器集群、vip+keepalive等   (可能会问到具体实现,所以在回答前要把这些实现细节搞得差不多懂)
应用层面(下面只要你提到,面试官都可能会问细节,比如有哪些存储引擎,各有什么区别和应用场景,innodb的主键索引和非主键索引有何区别,数据结构,叶子节点存放什么?)
    存储引擎的选择
    字段的选择
        越短越快
        定长类型快于变长类型
        整型的处理速度快于字符串类型
    索引
       MYSQL支持的索引类型 (讲到这肯定会问你具体定义)
       索引的使用条件
       索引的实现结构
           聚簇索引（聚集索引），非聚集索引，B+Tree
           HASH索引
    慢查询日志
        可帮助找到问题语句
    通过explain来优化sql语句
```

#什么是 mysql 慢查询？又该如何优化？
```
mysql 中查询超过指定时间的语句，被称之为「慢查询」。该如何优化呢？优化 SQL 语句，创建合适的索引，如以上两个问题。

```

#mysql 分库分表怎么设计
```
1.垂直分表
垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段，拆分出去放到“扩展表”中。

2.垂直分库
基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。

3.水平分表
水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。

4.水平分库
水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据库中。

```

#什么是 mysql 的事物？事物都有那些特性？
```
事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，

原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
```

# 什么是索引，作用是什么？常见索引类型有那些？mysql 建立索引的原则？
```
索引是一种特殊的文件,它们包含着对数据表里所有记录的引用指针，相当于书本的目录。其作用就是加快数据的检索效率。
常见索引类型有主键、唯一索引、复合索引、全文索引。


索引创建的原则:
    最左前缀原理
    尽量的去扩展索引，而不是重复的新建新索引
```

#依据是否聚簇区分索引
```
聚簇索引:
    引擎类型：InnoDB
    叶子结点存放数据本身

非聚簇索引:
    引擎类型：MyISAM
    叶子结点存的指针指向数据的实际地址，索引和数据分开
```

#索引底层数据结构
```
1.hash索引
    优点:
        效率高，一次查找 时间复杂度O(1)

    缺点:
        只能进行=，<=>，in查询，无法进行范围查询
        无法排序
        无法避免回表查找

    低层实现:
        hash表(散列表)

2.b+tree索引
```

#mysql中主键与唯一索引的区别?
```
主键是一种约束，唯一索引是一种索引，两者在本质上是不同的
主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键
唯一性索引列允许空值，而主键列不允许为空值
主键列在创建时，已经默认为空值 + 唯一索引了
主键可以被其他表引用为外键，而唯一索引不能
一个表最多只能创建一个主键，但可以创建多个唯一索引
主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等
在 RBO 模式下，主键的执行计划优先级要高于唯一索引。 两者可以提高查询的速度
```


#熟悉的 nosql 和 sql 有什么区别
```
Memcache，Redis 都是内存数据库 redis是一个开源的支持多种数据类型的key=>value的存储数据库。支持字符串、列表、集合、有序集合、哈希五种类型 memcache 只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。 无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失
```


#MySQL连接池
```
连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。

注意:
1. 最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。            
2. 最大连接数 是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。
```


























































































